#include <cstdio>
#include "huffman_tree.h"
#include <string.h>
#include <queue>
//#include "encoder.h"
//#include "decoder.h"
//#include "vector.h"
/**
 * 用于计算频率
 */
//using std::stringstream;


struct byte
{
};


int emset (char * mem, int v, int size)
{
    for (int i = 0; i < size-1; i ++) {
        mem[i] = v;
    }
    return size;
}
int * get_rate(const char * filename)
{
    int * rate = new int[257];
    memset((char*)rate,0,257*sizeof(int));
    FILE * fp = fopen(filename,"rb");
    if (fp == NULL) return rate;
    char ch = 0;
    while(1 ){
        ch = fgetc(fp);
        if (feof(fp)) break;
        rate[(unsigned char)ch] ++;
        if (ch <= 20) 
            printf("\\%d ",ch);
        else 
            printf("%c",ch);
    }

    printf("\n");
    fclose(fp);
    return rate;
}

node * get_tree(int * rate)
{
    node  *forest[257] = {NULL};
    int fs = 0;
   // memset((char*)forest,0,sizeof(node)*257);
   printf("字节频率统计:\n");
    for (int i = 0 ; i < 257; i ++) {
        if (rate[i] != 0) {
            forest[fs] = new node;
            forest[fs]->c = i;
            forest[fs]->nt = LEAF;
            forest[fs]->w = rate[i];
            forest[fs]->left = forest[fs]->right = NULL;
            fs ++;
            if (i<21)
                printf("\\%d[%d]",i,rate[i]);
            else
                printf("%c[%d] ",i,rate[i]);
        }
    }

    printf("\n");
    fflush(stdout);
    while (fs > 1) {
        /* 将最小的放到最后 */
        for (int i = 0 ; i < fs; i++) {
            if (forest[i]->w < forest[fs-1]->w) {
                node * t = forest[i];
                forest[i] = forest[fs-1];
                forest[fs-1] = t;
            }
        }
        
        for (int i = 0 ; i < fs-1; i++) {
            if (forest[i]->w < forest[fs-2]->w) {
                node * t = forest[i];
                forest[i] = forest[fs-2];
                forest[fs-2] = t;
            }
        }

        node * new_tree = new node;
        new_tree->w = forest[fs-1]->w + forest[fs-2]->w;
        new_tree->nt = BRANCH;
        new_tree->left = forest[fs-1];
        forest[fs-1]->parent = new_tree;
        new_tree->right = forest[fs-2];
        forest[fs-2]->parent = new_tree;
        fs --;
        forest[fs-1] = new_tree;
    } 
    return forest[0];
}


char * word[257] = {NULL};
char wbit[100] = {0};
int wp = 0;
void recur_dict(node *root)
{
    if (root == NULL) return;
    if (root->nt != LEAF) {
        //printf("%d ",root->w);
        wbit[wp++] = '0';
        recur_dict(root->left);
        wbit[wp++] = '1';
        recur_dict(root->right);
    }else {
        if (root->c > 20)
            printf("  \'%c\' [%d] ",root->c,root->w);
        else
            printf("\'\\%d\' [%d] ",root->c, root->w);
       
        word[root->c] = new char[wp];
        int i = 0;
        for ( i = 0 ; i < wp; i ++) {
            word[root->c][i] = wbit[i];
        }
        word[root->c][i] = 0;
        printf(" %s\n",word[root->c]);
    }
    wp --;
}


/* 打印树 */
int get_height_of_tree(node * root)
{
    if (root->nt == LEAF) return 1;
    int ll = get_height_of_tree(root->left);
    int rl = get_height_of_tree(root->right);
    if (ll > rl ) {
        return ll+1;
    }else {
        return rl+1;
    }
}

//template<typename T>
struct nl
{
    node * n;
    struct nl * next;
};

/*
template <typename T>
class queue
{
    nl<T> * b;
    nl<T> * e;
    int l = 0;
public:

};
*/
int llen(nl * s,nl * e)
{
    if (s == e) return 1;
    else return 1+llen(s->next,e);
}

bool check_all_null(nl * s,nl * e)
{
    if (s->n != NULL) return false;
    if (s == e && s->n == NULL) return true;
    return true;
}

void cn(char c,int n)
{
    for (int j = 0; j < n ; j++) {
        printf("%c",c);

    }
}
void nextl(int i)
{
    for (int j = 0; j < i ; j++) {
        printf("\n");
    }

}
int get_tab_of_level(int l)
{
    if(l == 0) return 2;
    else if (l > 0)
        return (get_tab_of_level(l-1)*2)+1;
    else 
        return 0;
}
void p_tree(node *root)
{
    printf("哈夫曼树结构:\n");
    int  h = get_height_of_tree(root);
    printf("%d\n",h);
    nl * s,*e;
    s = e = new nl;
    s->n = root;
    s->next = NULL;
    while (h>= 0) {
        int nowl = llen(s,e);
            int sc = get_tab_of_level(h-1);
        for (int i = 0 ; i < nowl; i ++) {
               
            cn(' ',sc-2);
            if (s->n != NULL) {
                if (s->n->nt == LEAF) {
                    if (s->n->c > 20)
                    printf("%3c",s->n->c);
                else 
                    printf(" \\%d",s->n->c);
                }
                else 
                    printf("%3d",s->n->w);
            }else 
                printf ("   ");
            cn(' ',sc+1);
            fflush(stdout);
            nl * l = new nl;
            nl * r = new nl;
            if ( s->n == NULL || s->n->nt == LEAF) {
                l->n = NULL;
                r->n = NULL;
            }else {
                l->n = s->n->left;
                r->n = s->n->right;
            }
            if (e != NULL) {
            e->next = l;
            e = e->next;
            e->next = r;
            e = e->next;
            }

            nl * t = s;
            if (s!=NULL)
            s = s->next;
            delete t;
        }
        h--;
        nextl(h+1);
    }
    nextl(1);
    fflush(stdout);
}

int main (int argc, char *argv[])
{
    int * rate = get_rate(argv[1]);
    node * t = get_tree(rate);
    p_tree(t);
    printf("编码字典:\n");
    recur_dict(t);
}
